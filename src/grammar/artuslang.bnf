/*
 * Copyright 2017 - present Frederic Artus Nieto
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

{
  parserClass="com.artuslang.lang.parser.ArtusParser"
  parserUtilClass="com.artuslang.lang.parser.ArtusParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
  parserImports = "static org.intellij.grammar.parser.GeneratedParserUtilBase.*;"

  psiClassPrefix="Artus"
  psiImplClassSuffix="Impl"
  psiPackage="com.artuslang.lang.psi"
  psiImplPackage="com.artuslang.lang.psi.impl"

  tokens=[
    LP='('
    RP=')'
    LB='{'
    RB='}'
    DT='.'
    SEMI=';'
    COLON=':'
    COM=','
    CO='<'
    CC='>'
    AP='`'

    ESC = "regexp:\\(['\"`\\?abtnvfre] | {UNICODE} | {HEXADECIMAL} | {ESCOCT})"
    UNICODE = "regexp:u[0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F]"
    //BUNICODE = "regexp:U[0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F] [0-9a-fA-F]"
    ESCOCT = "regexp:[0-7] [0-7] [0-7]"

    DECIMAL = "regexp:[1-9][0-9]*"
    SDECIMAL = "regexp:-{DECIMAL}"
    OCTAL = "regexp:0o[0-7]+"
    HEXADECIMAL = "regexp:0x[0-9a-fA-F]+"
    BINARY = "regexp:0b[0-1]+"
    FLOAT = "regexp:-?([1-9][0-9]* | '0')(\.[0-9]*)?(('e' | 'E')(-|\+)?[1-9][0-9]*)?"

    CHAR = "regexp:'([^'\\]|{ESC})'"

    STRING = "regexp:\"([^\"\\]|{ESC})*\""

    NAME_ = "regexp:[a-zA-Z_][0-9a-zA-Z_]*"

    OP = "regexp:('<' | '>')?[&#|\^@%!:?/*$ยง+=\-]+"

  ]
}

root ::= scopeElement*

scopeStatement ::= identifierChain (operator operatorIdentifierChain)* ';'?

scopeDefinition ::= identifierGroup? definition (operator operatorIdentifierChain)* ';'?

identifiedScope ::= identifierGroup? definedScope

definedScope ::= definerChain anonymousScope

anonymousScope ::= '{' scopeElement* '}'

scopeElement ::= anonymousScope
               | scopeStatement
               | scopeDefinition
               | definedScope
               | identifiedScope


operatorIdentifierChain ::= identifierChain | '(' operatorIdentifierChain (operator operatorIdentifierChain)* ')'

definerChain ::= (operatorIdentifierChain '.')? definer

definer ::= denomination templateDef? callDef?

identifierGroup ::= identifierChain+

identifierChain ::= identifier ('.' identifier)*

identifier ::= nameIdentifier | floatIdentifier | integerIdentifier | stringIdentifier | operatorIdentifier


nameIdentifier ::=  denomination template? call?

floatIdentifier ::= FLOAT

integerIdentifier ::= DECIMAL | SDECIMAL | OCTAL | HEXADECIMAL | CHAR | BINARY

stringIdentifier ::= STRING

operatorIdentifier ::= '`' operator '`'


template ::= '<' operatorIdentifierChain (',' operatorIdentifierChain)? '>'

templateDef ::= '<' definition (',' definition)?  '>'

call ::= '(' operatorIdentifierChain (',' operatorIdentifierChain)? ')'

callDef ::= '(' definition (',' definition)? ')'

definition ::= denomination ':' operatorIdentifierChain

operator ::= '<' | '>' | ':' | OP

denomination ::= NAME_